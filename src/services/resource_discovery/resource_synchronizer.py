"""
ËµÑÊ∫êÂêåÊ≠•Âô®

Âü∫‰∫é Ti-Flow ÁöÑ IncrementalVectorizer ËÆæËÆ°ÔºåÂÆûÁé∞Êô∫ËÉΩËµÑÊ∫êÂêåÊ≠•ÂíåÂ¢ûÈáèÊõ¥Êñ∞
"""

import logging
import hashlib
import json
from datetime import datetime
from typing import Dict, List, Any, Optional, Set, Tuple
from sqlalchemy.orm import Session
from sqlalchemy import text

from src.models.resource_discovery import (
    ResourceRegistry,
    ResourceRegistryCreate,
    VectorizationStatus,
    SystemStatus,
    SystemStatusCreate,
    OperationType,
    SystemStatusType
)
from .resource_discovery_service import ResourceDiscoveryService
from .resource_vectorizer import ResourceVectorizer

logger = logging.getLogger(__name__)


class ResourceSynchronizer:
    """ËµÑÊ∫êÂêåÊ≠•Âô® - Êô∫ËÉΩËµÑÊ∫êÂêåÊ≠•ÂíåÂ¢ûÈáèÊõ¥Êñ∞"""

    def __init__(self, embedding_service=None):
        """
        ÂàùÂßãÂåñÂêåÊ≠•Âô®

        Args:
            embedding_service: ÂµåÂÖ•ÊúçÂä°ÔºàÂ∑≤ÂºÉÁî®Ôºå‰ΩøÁî®Áªü‰∏ÄÁöÑÂµåÂÖ•ÊúçÂä°Ôºâ
        """
        self.discovery_service = ResourceDiscoveryService()
        self.vectorizer = ResourceVectorizer()
        
        # ÂΩ±ÂìçÂêëÈáèÂåñÁöÑÂ≠óÊÆµ
        self.vectorization_fields = {
            'resource_name', 'description', 'capabilities', 'tags', 'metadata'
        }
        
        logger.info("ÂàùÂßãÂåñËµÑÊ∫êÂêåÊ≠•Âô®")
    
    async def sync_and_vectorize_incremental(
        self, 
        session: Session,
        force_full_sync: bool = False
    ) -> Dict[str, Any]:
        """ÊâßË°åÂ¢ûÈáèÂêåÊ≠•ÂíåÂêëÈáèÂåñ"""
        start_time = datetime.utcnow()
        operation_id = await self._create_operation_status(
            session, OperationType.SYNC, SystemStatusType.RUNNING
        )
        
        logger.info(f"üöÄ ÂºÄÂßãÂ¢ûÈáèÂêåÊ≠•: force_full={force_full_sync}")
        
        try:
            if force_full_sync:
                # Âº∫Âà∂ÂÖ®ÈáèÂêåÊ≠•
                return await self._execute_full_sync(session, operation_id, start_time)
            else:
                # Êô∫ËÉΩÂ¢ûÈáèÂêåÊ≠•
                return await self._execute_incremental_sync(session, operation_id, start_time)
                
        except Exception as e:
            logger.error(f"‚ùå Â¢ûÈáèÂêåÊ≠•Â§±Ë¥•: {e}")
            await self._update_operation_status(
                session, operation_id, SystemStatusType.FAILED, error_message=str(e)
            )
            return {
                "success": False,
                "message": f"Â¢ûÈáèÂêåÊ≠•Â§±Ë¥•: {str(e)}",
                "total_processing_time": str(datetime.utcnow() - start_time)
            }

    async def incremental_sync(self, force_full_sync: bool = False) -> Dict[str, Any]:
        """Â¢ûÈáèÂêåÊ≠•ËµÑÊ∫ê (API ÈÄÇÈÖçÊñπÊ≥ï)"""
        from src.database import get_db_session

        session = next(get_db_session())
        try:
            return await self.sync_and_vectorize_incremental(session, force_full_sync)
        finally:
            session.close()

    async def _execute_incremental_sync(
        self, 
        session: Session,
        operation_id: int,
        start_time: datetime
    ) -> Dict[str, Any]:
        """ÊâßË°åÊô∫ËÉΩÂ¢ûÈáèÂêåÊ≠•"""
        logger.info("üîÑ ÊâßË°åÊô∫ËÉΩÂ¢ûÈáèÂêåÊ≠•...")
        
        # 1. Ê£ÄÊµãËµÑÊ∫êÂèòÊõ¥
        changes = await self._detect_resource_changes(session)
        
        # 2. Â§ÑÁêÜËµÑÊ∫êÂèòÊõ¥
        logger.info(f"üîÑ Â§ÑÁêÜ {len(changes)} ‰∏™ËµÑÊ∫êÂèòÊõ¥...")
        result = await self._process_resource_changes(session, changes)
        
        # 3. Êõ¥Êñ∞Êìç‰ΩúÁä∂ÊÄÅ
        processing_time = datetime.utcnow() - start_time
        await self._update_operation_status(
            session, operation_id, SystemStatusType.COMPLETED,
            total_items=len(changes),
            successful_items=result["successful_changes"],
            failed_items=result["failed_changes"],
            duration_seconds=int(processing_time.total_seconds()),
            result_data=result
        )
        
        return {
            "success": True,
            "message": f"Â¢ûÈáèÂêåÊ≠•ÂÆåÊàêÔºåÂ§ÑÁêÜ‰∫Ü {len(changes)} ‰∏™ÂèòÊõ¥",
            "processed_changes": result["change_summary"],
            "total_processing_time": str(processing_time),
            "performance_improvement": self._calculate_performance_improvement(
                len(changes), result["total_resources"]
            ),
            "detailed_results": result
        }
    
    async def _execute_full_sync(
        self, 
        session: Session,
        operation_id: int,
        start_time: datetime
    ) -> Dict[str, Any]:
        """ÊâßË°åÂº∫Âà∂ÂÖ®ÈáèÂêåÊ≠•"""
        logger.info("üîÑ ÊâßË°åÂº∫Âà∂ÂÖ®ÈáèÂêåÊ≠•...")
        
        # 1. Ê∏ÖÁêÜÁé∞ÊúâÊï∞ÊçÆ
        await self._cleanup_existing_data(session)
        
        # 2. ÈáçÊñ∞ÂèëÁé∞ÊâÄÊúâËµÑÊ∫ê
        resources = await self.discovery_service.discover_all_resources(session)
        
        # 3. Ê≥®ÂÜåÊâÄÊúâËµÑÊ∫ê
        registered_count = 0
        for resource in resources:
            if await self._register_resource_to_db(session, resource):
                registered_count += 1
        
        # 4. ÂêëÈáèÂåñÊâÄÊúâËµÑÊ∫ê
        vectorized_resources = await self.vectorizer.batch_vectorize_resources(session, resources)
        vectorized_count = sum(1 for r in vectorized_resources if r.get("vectorization_status") == "completed")
        
        # 5. Êõ¥Êñ∞Êìç‰ΩúÁä∂ÊÄÅ
        processing_time = datetime.utcnow() - start_time
        await self._update_operation_status(
            session, operation_id, SystemStatusType.COMPLETED,
            total_items=len(resources),
            successful_items=vectorized_count,
            failed_items=len(resources) - vectorized_count,
            duration_seconds=int(processing_time.total_seconds()),
            result_data={
                "total_discovered": len(resources),
                "total_registered": registered_count,
                "total_vectorized": vectorized_count
            }
        )
        
        return {
            "success": True,
            "message": f"ÂÖ®ÈáèÂêåÊ≠•ÂÆåÊàêÔºåÂ§ÑÁêÜ‰∫Ü {len(resources)} ‰∏™ËµÑÊ∫ê",
            "total_discovered": len(resources),
            "total_registered": registered_count,
            "total_vectorized": vectorized_count,
            "total_processing_time": str(processing_time)
        }
    
    async def _detect_resource_changes(self, session: Session) -> List[Dict[str, Any]]:
        """Ê£ÄÊµãËµÑÊ∫êÂèòÊõ¥"""
        changes = []
        
        try:
            # 1. ÂèëÁé∞ÂΩìÂâçÊâÄÊúâËµÑÊ∫ê
            current_resources = await self.discovery_service.discover_all_resources(session)
            
            # 2. Ëé∑ÂèñÂ∑≤Ê≥®ÂÜåÁöÑËµÑÊ∫ê
            registered_resources = await self._get_registered_resources(session)
            
            # 3. ÊØîËæÉÂèòÊõ¥
            current_resource_map = {r["resource_id"]: r for r in current_resources}
            registered_resource_map = {r["resource_id"]: r for r in registered_resources}
            
            # Ê£ÄÊµãÊñ∞Â¢ûËµÑÊ∫ê
            for resource_id, resource in current_resource_map.items():
                if resource_id not in registered_resource_map:
                    changes.append({
                        "change_type": "added",
                        "resource_id": resource_id,
                        "resource": resource
                    })
            
            # Ê£ÄÊµã‰øÆÊîπËµÑÊ∫ê
            for resource_id, current_resource in current_resource_map.items():
                if resource_id in registered_resource_map:
                    registered_resource = registered_resource_map[resource_id]
                    if self._has_resource_changed(current_resource, registered_resource):
                        changes.append({
                            "change_type": "modified",
                            "resource_id": resource_id,
                            "resource": current_resource,
                            "old_resource": registered_resource
                        })
            
            # Ê£ÄÊµãÂà†Èô§ËµÑÊ∫ê
            for resource_id, registered_resource in registered_resource_map.items():
                if resource_id not in current_resource_map:
                    changes.append({
                        "change_type": "deleted",
                        "resource_id": resource_id,
                        "resource": registered_resource
                    })
            
            logger.info(f"Ê£ÄÊµãÂà∞ {len(changes)} ‰∏™ËµÑÊ∫êÂèòÊõ¥")
            return changes
            
        except Exception as e:
            logger.error(f"Ê£ÄÊµãËµÑÊ∫êÂèòÊõ¥Â§±Ë¥•: {e}")
            return []
    
    async def _get_registered_resources(self, session: Session) -> List[Dict[str, Any]]:
        """Ëé∑ÂèñÂ∑≤Ê≥®ÂÜåÁöÑËµÑÊ∫ê"""
        try:
            query = text("""
                SELECT resource_id, resource_name, resource_type, description, 
                       capabilities, tags, metadata, is_active, status,
                       source_table, source_id, vectorization_status,
                       usage_count, success_rate, avg_response_time,
                       created_at, updated_at
                FROM resource_discovery.resource_registry
                ORDER BY resource_id
            """)
            
            result = session.execute(query)
            resources = []
            
            for row in result.fetchall():
                resource = {
                    "resource_id": row.resource_id,
                    "resource_name": row.resource_name,
                    "resource_type": row.resource_type,
                    "description": row.description,
                    "capabilities": row.capabilities,
                    "tags": row.tags,
                    "metadata": row.metadata,
                    "is_active": row.is_active,
                    "status": row.status,
                    "source_table": row.source_table,
                    "source_id": row.source_id,
                    "vectorization_status": row.vectorization_status,
                    "usage_count": row.usage_count,
                    "success_rate": row.success_rate,
                    "avg_response_time": row.avg_response_time,
                    "created_at": row.created_at,
                    "updated_at": row.updated_at
                }
                resources.append(resource)
            
            return resources
            
        except Exception as e:
            logger.error(f"Ëé∑ÂèñÂ∑≤Ê≥®ÂÜåËµÑÊ∫êÂ§±Ë¥•: {e}")
            return []
    
    def _has_resource_changed(self, current: Dict[str, Any], registered: Dict[str, Any]) -> bool:
        """Ê£ÄÊü•ËµÑÊ∫êÊòØÂê¶ÂèëÁîüÂèòÊõ¥"""
        try:
            # Ê£ÄÊü•ÂΩ±ÂìçÂêëÈáèÂåñÁöÑÂ≠óÊÆµ
            for field in self.vectorization_fields:
                current_value = current.get(field)
                registered_value = registered.get(field)
                
                # ÂØπ‰∫é JSON Â≠óÊÆµÔºåÈúÄË¶ÅÁâπÊÆäÂ§ÑÁêÜ
                if field in ['capabilities', 'tags', 'metadata']:
                    current_hash = self._get_json_hash(current_value)
                    registered_hash = self._get_json_hash(registered_value)
                    if current_hash != registered_hash:
                        return True
                else:
                    if current_value != registered_value:
                        return True
            
            return False
            
        except Exception as e:
            logger.error(f"Ê£ÄÊü•ËµÑÊ∫êÂèòÊõ¥Â§±Ë¥•: {e}")
            return True  # Âá∫ÈîôÊó∂ËÆ§‰∏∫ÊúâÂèòÊõ¥ÔºåÁ°Æ‰øùÂÆâÂÖ®
    
    def _get_json_hash(self, data: Any) -> str:
        """Ëé∑Âèñ JSON Êï∞ÊçÆÁöÑÂìàÂ∏åÂÄº"""
        try:
            if data is None:
                return ""
            json_str = json.dumps(data, sort_keys=True, ensure_ascii=False)
            return hashlib.md5(json_str.encode()).hexdigest()
        except Exception:
            return str(hash(str(data)))
    
    async def _process_resource_changes(
        self, 
        session: Session, 
        changes: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """Â§ÑÁêÜËµÑÊ∫êÂèòÊõ¥"""
        successful_changes = 0
        failed_changes = 0
        change_summary = {"added": 0, "modified": 0, "deleted": 0}
        
        for change in changes:
            try:
                change_type = change["change_type"]
                resource_id = change["resource_id"]
                
                if change_type == "added":
                    # Êñ∞Â¢ûËµÑÊ∫ê
                    if await self._register_resource_to_db(session, change["resource"]):
                        await self.vectorizer.vectorize_resource(session, change["resource"])
                        successful_changes += 1
                        change_summary["added"] += 1
                    else:
                        failed_changes += 1
                
                elif change_type == "modified":
                    # ‰øÆÊîπËµÑÊ∫ê
                    if await self._update_resource_in_db(session, change["resource"]):
                        await self.vectorizer.vectorize_resource(session, change["resource"])
                        successful_changes += 1
                        change_summary["modified"] += 1
                    else:
                        failed_changes += 1
                
                elif change_type == "deleted":
                    # Âà†Èô§ËµÑÊ∫ê
                    if await self._delete_resource_from_db(session, resource_id):
                        successful_changes += 1
                        change_summary["deleted"] += 1
                    else:
                        failed_changes += 1
                
            except Exception as e:
                logger.error(f"Â§ÑÁêÜÂèòÊõ¥Â§±Ë¥• {change.get('resource_id')}: {e}")
                failed_changes += 1
        
        return {
            "successful_changes": successful_changes,
            "failed_changes": failed_changes,
            "change_summary": change_summary,
            "total_resources": len(changes)
        }
    
    async def _register_resource_to_db(self, session: Session, resource: Dict[str, Any]) -> bool:
        """Ê≥®ÂÜåËµÑÊ∫êÂà∞Êï∞ÊçÆÂ∫ì"""
        try:
            import json
            insert_query = text("""
                INSERT INTO resource_discovery.resource_registry
                (resource_id, resource_name, resource_type, description, capabilities,
                 tags, metadata, is_active, status, source_table, source_id, vectorization_status)
                VALUES (:resource_id, :resource_name, :resource_type, :description, :capabilities,
                        :tags, :metadata, :is_active, :status, :source_table, :source_id, :vectorization_status)
                ON CONFLICT (resource_id) DO NOTHING
            """)

            session.execute(insert_query, {
                "resource_id": resource["resource_id"],
                "resource_name": resource["resource_name"],
                "resource_type": resource["resource_type"],
                "description": resource.get("description"),
                "capabilities": json.dumps(resource.get("capabilities")) if resource.get("capabilities") else None,
                "tags": json.dumps(resource.get("tags")) if resource.get("tags") else None,
                "metadata": json.dumps(resource.get("metadata")) if resource.get("metadata") else None,
                "is_active": resource.get("is_active", True),
                "status": resource.get("status", "active"),
                "source_table": resource.get("source_table"),
                "source_id": resource.get("source_id"),
                "vectorization_status": VectorizationStatus.PENDING.value
            })
            session.commit()
            return True
            
        except Exception as e:
            session.rollback()
            logger.error(f"Ê≥®ÂÜåËµÑÊ∫êÂ§±Ë¥•: {e}")
            return False
    
    async def _update_resource_in_db(self, session: Session, resource: Dict[str, Any]) -> bool:
        """Êõ¥Êñ∞Êï∞ÊçÆÂ∫ì‰∏≠ÁöÑËµÑÊ∫ê"""
        try:
            import json
            update_query = text("""
                UPDATE resource_discovery.resource_registry
                SET resource_name = :resource_name, description = :description,
                    capabilities = :capabilities, tags = :tags, metadata = :metadata,
                    is_active = :is_active, status = :status,
                    vectorization_status = :vectorization_status,
                    updated_at = CURRENT_TIMESTAMP
                WHERE resource_id = :resource_id
            """)

            session.execute(update_query, {
                "resource_id": resource["resource_id"],
                "resource_name": resource["resource_name"],
                "description": resource.get("description"),
                "capabilities": json.dumps(resource.get("capabilities")) if resource.get("capabilities") else None,
                "tags": json.dumps(resource.get("tags")) if resource.get("tags") else None,
                "metadata": json.dumps(resource.get("metadata")) if resource.get("metadata") else None,
                "is_active": resource.get("is_active", True),
                "status": resource.get("status", "active"),
                "vectorization_status": VectorizationStatus.PENDING.value
            })
            session.commit()
            return True
            
        except Exception as e:
            session.rollback()
            logger.error(f"Êõ¥Êñ∞ËµÑÊ∫êÂ§±Ë¥•: {e}")
            return False
    
    async def _delete_resource_from_db(self, session: Session, resource_id: str) -> bool:
        """‰ªéÊï∞ÊçÆÂ∫ì‰∏≠Âà†Èô§ËµÑÊ∫ê"""
        try:
            delete_query = text("""
                DELETE FROM resource_discovery.resource_registry 
                WHERE resource_id = :resource_id
            """)
            
            session.execute(delete_query, {"resource_id": resource_id})
            session.commit()
            return True
            
        except Exception as e:
            session.rollback()
            logger.error(f"Âà†Èô§ËµÑÊ∫êÂ§±Ë¥•: {e}")
            return False
    
    async def _cleanup_existing_data(self, session: Session):
        """Ê∏ÖÁêÜÁé∞ÊúâÊï∞ÊçÆ"""
        try:
            # Âà†Èô§ÊâÄÊúâÂêëÈáèÊï∞ÊçÆ
            session.execute(text("DELETE FROM resource_discovery.resource_vectors"))
            # Âà†Èô§ÊâÄÊúâËµÑÊ∫êÊ≥®ÂÜåÊï∞ÊçÆ
            session.execute(text("DELETE FROM resource_discovery.resource_registry"))
            session.commit()
            logger.info("Ê∏ÖÁêÜÁé∞ÊúâÊï∞ÊçÆÂÆåÊàê")
        except Exception as e:
            session.rollback()
            logger.error(f"Ê∏ÖÁêÜÊï∞ÊçÆÂ§±Ë¥•: {e}")
    
    def _calculate_performance_improvement(self, processed_count: int, total_count: int) -> str:
        """ËÆ°ÁÆóÊÄßËÉΩÊèêÂçá"""
        if total_count == 0:
            return "N/A"
        
        improvement = (1 - processed_count / total_count) * 100
        return f"{improvement:.1f}% (Â§ÑÁêÜ {processed_count}/{total_count} ‰∏™ËµÑÊ∫ê)"
    
    async def _create_operation_status(
        self, 
        session: Session, 
        operation_type: OperationType, 
        status: SystemStatusType
    ) -> int:
        """ÂàõÂª∫Êìç‰ΩúÁä∂ÊÄÅËÆ∞ÂΩï"""
        try:
            insert_query = text("""
                INSERT INTO resource_discovery.system_status 
                (operation_type, status, started_at)
                VALUES (:operation_type, :status, :started_at)
                RETURNING id
            """)
            
            result = session.execute(insert_query, {
                "operation_type": operation_type.value,
                "status": status.value,
                "started_at": datetime.utcnow()
            })
            session.commit()
            
            return result.fetchone()[0]
            
        except Exception as e:
            session.rollback()
            logger.error(f"ÂàõÂª∫Êìç‰ΩúÁä∂ÊÄÅÂ§±Ë¥•: {e}")
            return 0
    
    async def _update_operation_status(
        self, 
        session: Session, 
        operation_id: int, 
        status: SystemStatusType,
        total_items: int = 0,
        successful_items: int = 0,
        failed_items: int = 0,
        duration_seconds: int = 0,
        error_message: Optional[str] = None,
        result_data: Optional[Dict[str, Any]] = None
    ):
        """Êõ¥Êñ∞Êìç‰ΩúÁä∂ÊÄÅ"""
        try:
            update_query = text("""
                UPDATE resource_discovery.system_status 
                SET status = :status, total_items = :total_items,
                    successful_items = :successful_items, failed_items = :failed_items,
                    duration_seconds = :duration_seconds, error_message = :error_message,
                    result_data = :result_data, completed_at = :completed_at,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = :operation_id
            """)
            
            import json
            session.execute(update_query, {
                "operation_id": operation_id,
                "status": status.value,
                "total_items": total_items,
                "successful_items": successful_items,
                "failed_items": failed_items,
                "duration_seconds": duration_seconds,
                "error_message": error_message,
                "result_data": json.dumps(result_data) if result_data else None,
                "completed_at": datetime.utcnow() if status in [SystemStatusType.COMPLETED, SystemStatusType.FAILED] else None
            })
            session.commit()
            
        except Exception as e:
            session.rollback()
            logger.error(f"Êõ¥Êñ∞Êìç‰ΩúÁä∂ÊÄÅÂ§±Ë¥•: {e}")
